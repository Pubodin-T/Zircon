<!DOCTYPE html>
<html lang="en">
  {% load static %}
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.93/Build/Cesium/Cesium.js"></script>
    <link
      href="https://cesium.com/downloads/cesiumjs/releases/1.93/Build/Cesium/Widgets/widgets.css"
      rel="stylesheet"
    />
    <title>Cesium</title>
  </head>
  <body>
    <div id="cesiumContainer"></div>
    <div id="toolbar"></div>
    <h1>Norad ID : {{data}}</h1>
    <h1>SATNAME : {{data.sat_name}}</h1>
    <h1>Intldes : {{data.intldes}}</h1>
    <h1>Country : {{data.country}}</h1>
    <h1>Msg epoch: : {{data.msg_epoch}}</h1>
    <h1>Decay epoch : {{data.decay_epoch}}</h1>
    <h1>Rcs : {{data.rcs}}</h1>
    <h1>Source : {{data.source}}</h1>
    <h1>Typeobj : {{data.typeobj}}</h1>
    <button onclick="myFunction()">Click me</button>
    <script >
      // Your access token can be found at: https://cesium.com/ion/tokens.
      // This is the default access token from your ion account
      function myFunction(){
        alert("Click")
        viewer.trackedEntity = airplaneEntity;
      }
      Cesium.Ion.defaultAccessToken =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIwZjhmYzkzOS1jNzI3LTQyZTQtYWJhYS00NGM0MDkxZjRkNmEiLCJpZCI6OTU5MTksImlhdCI6MTY1NDA1MjA1N30.zYK1AbmYJRYuMrU9-YayuYw8j96IEKkvpOmMjGsvr_8";

      // STEP 4 CODE (replaces steps 2 and 3)
      // Keep your `Cesium.Ion.defaultAccessToken = 'your_token_here'` line from before here.
      const viewer = new Cesium.Viewer("cesiumContainer", {
        terrainProvider: Cesium.createWorldTerrain(),
      });
      const osmBuildings = viewer.scene.primitives.add(
        Cesium.createOsmBuildings()
      );

      

      /* Initialize the viewer clock:
        Assume the radar samples are 30 seconds apart, and calculate the entire flight duration based on that assumption.
        Get the start and stop date times of the flight, where the start is the known flight departure time (converted from PST
          to UTC) and the stop is the start plus the calculated duration. (Note that Cesium uses Julian dates. See
          https://simple.wikipedia.org/wiki/Julian_day.)
        Initialize the viewer's clock by setting its start and stop to the flight start and stop times we just calculated.
        Also, set the viewer's current time to the start time and take the user to that time.
      */
      // Animate of data ex.1s per lat long
      const plot = "{{data.dataset}}";

      let re = /[\-| ][0-9]+\.[0-9]+/gm;
      let result = plot.match(re);
      let index = 0;
      var latitude = [];
      var longitude = [];
      var height = [];
      //console.log({{data.msg_epoch}})
      for (let l = 0; l< result.length;l++){
        if(index === 6){
          // push height data
          height.push(parseFloat(result[l])*1000)
        }
        if(index === 7){
          // push lat data
          latitude.push(parseFloat(result[l]))
        }
        if(index === 8){
          // push long data
          longitude.push(parseFloat(result[l]))
        }

        index++;
        if(index>8){
          index=0;
        }
      } 
      
      const timeStepInSeconds = 1;
      const totalSeconds = timeStepInSeconds * result.length;

      const start = Cesium.JulianDate.fromIso8601("2018-01-27T19:52:30Z");
      const stop = Cesium.JulianDate.addSeconds(
        start,
        totalSeconds,
        new Cesium.JulianDate()
      );
      viewer.clock.startTime = start.clone();
      viewer.clock.stopTime = stop.clone();
      viewer.clock.currentTime = start.clone();
      viewer.timeline.zoomTo(start, stop);
      // Speed up the playback speed 50x.
      viewer.clock.multiplier = 1;
      // Start playing the scene.
      viewer.clock.shouldAnimate = true;

      // The SampledPositionedProperty stores the position and timestamp for each sample along the radar sample series.
      const positionProperty = new Cesium.SampledPositionProperty();
      
      for (let i = 0; i < latitude.length; i++) {
        //const dataPoint = result[i];
        // Declare the time for this individual sample and store it in a new JulianDate instance.
        const time = Cesium.JulianDate.addSeconds(
          start,
          i * timeStepInSeconds,
          new Cesium.JulianDate()
        );
        const position = Cesium.Cartesian3.fromDegrees(
          longitude[i],
          latitude[i],
          height[i]
        );

        // Store the position along with its timestamp.
        // Here we add the positions all upfront, but these can be added at run-time as samples are received from a server.
        positionProperty.addSample(time, position);
        viewer.entities.add({
          description: `Location: (${longitude[i]}, ${latitude[i]}, ${height[i]})`,
          position: position,
          point: { pixelSize: 0, color: Cesium.Color.GREEN },
        });
      }

      // STEP 6 CODE (airplane entity)
      const positionRocket = Cesium.Cartesian3.fromDegrees()
      async function loadModel() {
        // Load the glTF model from Cesium ion.
        const airplaneUri = await Cesium.IonResource.fromAssetId(1111699);
        const airplaneEntity = viewer.entities.add({
          availability: new Cesium.TimeIntervalCollection([
            new Cesium.TimeInterval({ start: start, stop: stop }),
          ]),
          position: positionProperty,
          // Attach the 3D model instead of the green point.
          model: { uri: airplaneUri },
          // Automatically compute the orientation from the position.
          orientation: new Cesium.VelocityOrientationProperty(positionProperty),
          path: new Cesium.PathGraphics({ width: 3 }),
          name : "{{data.sat_name}}",

        });
        airplaneEntity.InfoBox("Hi")
        viewer.trackedEntity = airplaneEntity;
      }

      loadModel();

      function myFunction(){
        alert("Click")
        loadModel();
      }
      console.log("Load Model Success")
    </script>
  </body>
</html>


