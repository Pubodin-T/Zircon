<!DOCTYPE html>
<html lang="en">
  {% load static %}
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      http-equiv="Content-type"
      content="application/x-www-form-urlencoded; charset=utf-8"
    />
    <meta http-equiv="Cache-control" content="public" />
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.93/Build/Cesium/Cesium.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Mono&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://cesium.com/downloads/cesiumjs/releases/1.93/Build/Cesium/Widgets/widgets.css"
      rel="stylesheet"
    />
    {% comment %}
    <link rel="stylesheet" href="{% static '/frontend/css/style.css' %}" />
    {% endcomment %}
    <title>Cesium</title>
    <style>
      html, body {
        height: 100%;
        margin: 0;
      }
      .container {
        display: flex;
        width: 100%;
        height: 100%;
      }
      #cesiumContainer {
        display: inline-block;
        width: 100%;
        height: 100%;
      }
      #cesiumContainer2 {
        display: inline-block;
        width: 100%;
        height: 100%;
      }
    </style>


    <style>
      .switch {
        position: relative;
        display: inline-block;
        width: 60px;
        height: 34px;
      }

      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        -webkit-transition: 0.4s;
        transition: 0.4s;
      }

      .slider:before {
        position: absolute;
        content: "";
        height: 26px;
        width: 26px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        -webkit-transition: 0.4s;
        transition: 0.4s;
      }

      input:checked + .slider {
        background-color: #2196f3;
      }

      input:focus + .slider {
        box-shadow: 0 0 1px #2196f3;
      }

      input:checked + .slider:before {
        -webkit-transform: translateX(26px);
        -ms-transform: translateX(26px);
        transform: translateX(26px);
      }

      /* Rounded sliders */
      .slider.round {
        border-radius: 34px;
      }

      .slider.round:before {
        border-radius: 50%;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div id="cesiumContainer" class="fullSize"></div>
      <div id="cesiumContainer2" class="fullSize"></div>
    </div>
    <div id="toolbar"></div>
    <div class="info-table" style="text-align: center">
      <table class="darkTable">
        <thead>
          <tr>
            <th colspan="5">Location <span class="display-status"></span></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Date</td>
            <td>Height</td>
            <td>Latitude</td>
            <td>Longtitude</td>
            <td>Velocity</td>
          </tr>
          <tr>
            <td><p class="display-time"></p></td>
            <td><p class="display-height"></p></td>
            <td><p class="display-lat"></p></td>
            <td><p class="display-long"></p></td>
            <td><p class="display-velocity"></p></td>
          </tr>
        </tbody>
      </table>
    </div>
    <button onClick="myFunction()">Test</button>
    <label class="switch">
      <input type="checkbox" onClick="trackedEntity()" checked />
      <span class="slider round"></span>
    </label>

    <label class="switch">
      <input type="checkbox" id="show-earth2" checked />
      <span class="slider round"></span>
    </label>
    <script>
      
      // Your access token can be found at: https://cesium.com/ion/tokens.
      // This is the default access token from your ion account


      Cesium.Ion.defaultAccessToken =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIwZjhmYzkzOS1jNzI3LTQyZTQtYWJhYS00NGM0MDkxZjRkNmEiLCJpZCI6OTU5MTksImlhdCI6MTY1NDA1MjA1N30.zYK1AbmYJRYuMrU9-YayuYw8j96IEKkvpOmMjGsvr_8";

      // STEP 4 CODE (replaces steps 2 and 3)
      // Keep your `Cesium.Ion.defaultAccessToken = 'your_token_here'` line from before here.

      // Render Cesium Map
      const viewer = new Cesium.Viewer("cesiumContainer", {
        terrainProvider: Cesium.createWorldTerrain(),
        geocoder: false,
        fullscreenButton: false,
        navigationHelpButton: false,
      });
      const osmBuildings = viewer.scene.primitives.add(
        Cesium.createOsmBuildings()
      );

      const viewer2 = new Cesium.Viewer("cesiumContainer2", {
        terrainProvider: Cesium.createWorldTerrain(),
        geocoder: false,
        fullscreenButton: false,
        navigationHelpButton: false,
        homeButton: false,
        infoBox: false,
        timeline: false,
        
      });
      // Pan Camera to Thailand by new Cesium.Rectangle(west, south, east, north)
      Cesium.Camera.DEFAULT_VIEW_RECTANGLE = Cesium.Rectangle.fromDegrees(63.076400,-31.700130,139.064604,52.234528);
      document.getElementById("animation_pathClock").style.display= "none";
      document.querySelector("#animation_pathWingButton.cesium-animation-buttonMain").style.display= "none";
      //Disable Columbus View
      document.querySelector("#cesiumContainer > div > div.cesium-viewer-toolbar > span.cesium-sceneModePicker-wrapper.cesium-toolbar-button > button:nth-child(4)").style.display = 'none';

      $(".cesium-baseLayerPicker-item").eq(3).css("display","none");
      $(".cesium-baseLayerPicker-item").eq(4).css("display","none");
      {% comment %} var credit = new Cesium.Credit(
        '<a href="https://www.facebook.com/" target="_blank"><img src="https://sv1.picz.in.th/images/2022/06/09/VWcK1R.png" style=" width:70px; height=40px; margin=200px; " title="Zircon"/> </a>'
      );


      //document.querySelector("#cesium-viewer-bottom").style.display= "none";
      viewer.scene.frameState.creditDisplay.addDefaultCredit(credit); {% endcomment %}
      {% comment %} $(document).ready(function() {
        $("#cesium-credit-textContainer").css({"display":"none"});
      }); {% endcomment %}

      // Edit Logo Here !!!

      $(".cesium-widget-credits").html('<div style="display: inline;"><a href="https://demo.gistda.or.th/news_view.php?n_id=2325&lang=EN" target="_blank"><img title="Zircon" src="{% static '/asset/zircon.png' %}" style=" width: 120px; height:80px " ></a></div>');

      // Animate of data ex.1s per lat long
      const dataset = "";
      const dateset = "{{date}}"
      // Regex get float data
      let re = /[\-| ][0-9]+\.[0-9]+/gm;
      let result = dataset.match(re);
      let index = 0;
      var latitude = [];
      var longitude = [];
      var height = [];
      var vx = [];
      var vy = [];
      var vz = [];
      var rcs = "{{rcs}}"
      let int = null;
      //console.log(dateset[1])
      //console.log({{velocity}}[0])
      //console.log({{height}}.length)
      //console.log({{latitude}})
      //console.log({{longitude}})

      //console.log({{data.msg_epoch}})
      {% comment %} for (let l = 0; l < result.length; l++) {
        if (index === 3) {
          // push lat data
          vx.push(parseFloat(result[l]));
        }
        if (index === 4) {
          // push lat data
          vy.push(parseFloat(result[l]));
        }
        if (index === 5) {
          // push lat data
          vz.push(parseFloat(result[l]));
        }

        if (index === 6) {
          // push height data
          height.push(parseFloat(result[l]) * 1000);
        }
        if (index === 7) {
          // push lat data
          latitude.push(parseFloat(result[l]));
        }
        if (index === 8) {
          // push long data
          longitude.push(parseFloat(result[l]));
        }

        index++;
        if (index > 8) {
          index = 0;
        }
      } {% endcomment %}

      // Regex Date and Format to ISO Format ex.2019-01-01T00:00:00.000Z
      let reTime = /\d{4}\-\d\d\-\d\dT\d\d:\d\d:\d\d\.\d*Z/gm;
      let resultTime = dateset.match(reTime);
      //console.log(resultTime[0])
      //let datetime = resultTime[0].replace(/\//g,"-").replace(/\s/g,"T") + "Z";
      //console.log(new Date(datetime).toISOString())
      var entityPosition = [];

      for (let k = 0; k < {{latitude}}.length; k++){
        entityPosition.push({
          lat : {{latitude}}[k],
          long : {{longitude}}[k],
          alt : {{height}}[k].toFixed(2),
          ti : Cesium.JulianDate.fromIso8601(resultTime[k]),
          velocity : {{velocity}}[k]
        });

      }

      //console.log(entityPosition)

      const timeStepInSeconds = 1;
      const totalSeconds = timeStepInSeconds * {{latitude}}.length + 1000;
      const start = Cesium.JulianDate.fromIso8601(resultTime[0]);
      const stop = Cesium.JulianDate.addSeconds(
        start,
        totalSeconds,
        new Cesium.JulianDate()
      );
      viewer.clock.startTime = start.clone();
      viewer.clock.stopTime = stop.clone();
      viewer.clock.currentTime = start.clone();
      viewer.timeline.zoomTo(start, stop);
      // Speed up the playback speed 50x.
      viewer.clock.multiplier = 1;
      // Start playing the scene.
      viewer.clock.shouldAnimate = true;

      viewer2.clock.startTime = start.clone();
      viewer2.clock.stopTime = stop.clone();
      viewer2.clock.currentTime = start.clone();
      // Speed up the playback speed 50x.
      viewer2.clock.multiplier = 1;
      // Start playing the scene.
      viewer2.clock.shouldAnimate = true;

      // The SampledPositionedProperty stores the position and timestamp for each sample along the radar sample series.
      const positionProperty = new Cesium.SampledPositionProperty();

      for (let i = 0; i < {{latitude}}.length; i++) {

        //const dataPoint = result[i];
        // Declare the time for this individual sample and store it in a new JulianDate instance.
        const time = Cesium.JulianDate.addSeconds(
          start,
          i * timeStepInSeconds,
          new Cesium.JulianDate()
        );
        const position = Cesium.Cartesian3.fromDegrees(
          {{longitude}}[i],
          {{latitude}}[i],
          {{height}}[i]*1000
        );
        //console.log(time)
        // Store the position along with its timestamp.
        // Here we add the positions all upfront, but these can be added at run-time as samples are received from a server.
        positionProperty.addSample(time, position);

        {% comment %} viewer.entities.add({
          name: "Location",
          description:
            `<table class="cesium-infoBox-defaultTable"><tbody><tr><th>Latitude : </th> <th> ${latitude[i]}</th></tr>` +
            `<tr><th>Longitude : </th><th>${longitude[i]}</th></tr>` +
            `<tr><th>Height : </th><th>${parseFloat(height[i] / 1000).toFixed(
              2
            )} km.</th></tr>`,
          position: position,
          point: { pixelSize: 5, color: Cesium.Color.RED },
        }); {% endcomment %}

      }

      // STEP 6 CODE (object entity)

      async function loadModel() {
        // Load the glTF model from Cesium ion.
        {% comment %} const heading = Cesium.Math.toRadians(35.5);
        const pitch = Cesium.Math.toRadians(180);
        const roll = Cesium.Math.toRadians(-90);
        const hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);
        console.log(longitude[1])
        const orientation = Cesium.Transforms.headingPitchRollQuaternion(
          Cesium.Cartesian3.fromDegrees(
          longitude[1],
          latitude[1],
          height[1]
        ),
          hpr
        ); {% endcomment %}

        const objectUri = await Cesium.IonResource.fromAssetId(1124763);
        
        const orientation = new Cesium.VelocityOrientationProperty(positionProperty)
        const objectEntity = viewer.entities.add({
          availability: new Cesium.TimeIntervalCollection([
            new Cesium.TimeInterval({ start: start, stop: stop }),
          ]),
          position: positionProperty,
          // Attach the 3D model instead of the green point.
          model: { uri: objectUri , minimumPixelSize: 64,},
          // Automatically compute the orientation from the position.
          orientation: orientation,
          path: new Cesium.PathGraphics({
            width: 3  ,
            material: Cesium.Color.WHITE,
          }),
          name: "{{data.sat_name}} " + "   ( {{data.typeobj}} )",
          description:
            `<table class="cesium-infoBox-defaultTable"><tbody><tr><th>NORAD ID : </th> <th> {{data}}</th></tr>` +
            `<tr><th>Intldes : </th><th>{{data.intldes}}</th></tr>` +
            `<tr><th>Country : </th><th>{{data.country}}</th></tr>` +
            `<tr><th>Msg Epoch : </th><th>{{data.msg_epoch}}</th></tr>` +
            `<tr><th>Decay Epoch : </th><th>{{data.decay_epoch}}</th></tr>` +
            `<tr><th>Rcs : </th><th>{{data.rcs}}</th></tr>` +
            `<tr><th>Source : </th><th>{{data.source}}</th></tr>` +
            `</tbody></table>`,
          label: {
              text: "{{data.sat_name}}",
              font: '16pt monospace',
              style: Cesium.LabelStyle.FILL_AND_OUTLINE,
              outlineWidth: 1,
              verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
              pixelOffset: new Cesium.Cartesian2(0, -50)
          }
        });
        console.log("Load Model 1")

        viewer.flyTo(objectEntity).then(function(){viewer.trackedEntity = objectEntity; viewer.selectedEntity = objectEntity;});
        //console.log(objectEntity.path.material.color._value)
        //$(".display-time").text(entityPosition.at(-1).ti);
      }
      async function loadModel2() {
        // Load the glTF model from Cesium ion.     
        const orientation = new Cesium.VelocityOrientationProperty(positionProperty)
        const objectUri2 = await Cesium.IonResource.fromAssetId(1111699);
        const objectEntity2 = viewer2.entities.add({
          availability: new Cesium.TimeIntervalCollection([
            new Cesium.TimeInterval({ start: start, stop: stop }),
          ]),
          model: { uri: objectUri2 , minimumPixelSize: 64,},
          position: positionProperty,
          // Attach the 3D model instead of the green point.
          // Automatically compute the orientation from the position.
          orientation: orientation,
          path: new Cesium.PathGraphics({
            width: 3  ,
            material: Cesium.Color.ORANGE,
          }),
          name: "{{data.sat_name}} " + "  ( {{data.typeobj}} )",
          label: {
              text: "{{data.sat_name}}",
              font: '16pt monospace',
              style: Cesium.LabelStyle.FILL_AND_OUTLINE,
              outlineWidth: 1,
              verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
              pixelOffset: new Cesium.Cartesian2(0, -50)
          }
        });
        console.log("Load Model 2")
        
        //console.log(objectEntity.path.material.color._value)
        //$(".display-time").text(entityPosition.at(-1).ti);
      }

      loadModel();
      loadModel2().then(function(){ console.log("Model Loaded"); int = setInterval(display, 50); display(); console.log()});

      function map(x, in_min, in_max, out_min, out_max) {
        return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
      }

      function myFunction() {
        console.log("Test")
        viewer.trackedEntity = undefined



        {% comment %} console.log(viewer.entities.values[0].position.getValue(viewer.clock.currentTime))
        var nowPo = viewer.entities.values[0].position.getValue(viewer.clock.currentTime)
        var test = {
          x:0,
          y:0,
          z:0
        }
        new Cesium.Cartesian3.add(nowPo, Cesium.Cartesian3.fromDegrees(15,35,0),test)

        console.log(test)
        viewer.camera.flyTo({
          destination: test,
          orientation: {
            heading: Cesium.Math.toRadians(20.0),
            pitch: Cesium.Math.toRadians(-35.0),
            roll: 0.0,
          },
        }); {% endcomment %}
        //viewer.scene.camera.lookAt(viewer.entities.values[0].position.getValue(viewer.clock.currentTime), new Cesium.Cartesian3(0,0,10000));
        //let serchObj = entityPosition.find((e) => parseInt(e.ti.secondsOfDay) == parseInt(viewer.clock.currentTime.secondsOfDay));
        //console.log(parseInt(viewer.clock.currentTime.secondsOfDay));
        //$(".display-time").text(viewer.clock.currentTime);
        //loadPath()
        //viewer.flyTo(viewer.entities.values[0],{ offset:new Cesium.HeadingPitchRange(Cesium.Math.toRadians(-15), Cesium.Math.toRadians(-20 ), 50000),duration : 5 }).then(function(){viewer.trackedEntity = viewer.entities.values[0]; viewer.selectedEntity = viewer.entities.values[0];});
      }
      console.log("Load Model Success");


      let isTracked = true;
      let searchObj = null;
      let green = 0;
      let red = 0;

      function display() {
        //console.log((e) => parseInt(e.ti.secondsOfDay) === parseInt(viewer.clock.currentTime.secondsOfDay))
        searchObj = entityPosition.find((e) => parseInt(e.ti.secondsOfDay) === parseInt(viewer.clock.currentTime.secondsOfDay) && e.ti.dayNumber === viewer.clock.currentTime.dayNumber);
        if(Cesium.JulianDate.greaterThan(viewer.clock.currentTime, entityPosition.at(-1).ti)){
          $(".display-status").text("( Object Dropped )")
          $(".display-height").text("0 km.")
          $(".display-lat").text(entityPosition.at(-1).lat)
          $(".display-long").text(entityPosition.at(-1).long)
          $(".display-velocity").text("0 km/s")
        }
        else if (searchObj !== undefined){
          $(".display-status").text("")
          $(".display-height").text( searchObj.alt + " km.")
          $(".display-lat").text( searchObj.lat)
          $(".display-long").text( searchObj.long)
          $(".display-velocity").text( searchObj.velocity.toFixed(2) + " km/s")
          let altitude = parseInt(searchObj.alt);
          if(altitude > 200){
            // Green Zone !!!
            green = 255;
            red = 0;
          }
          else if(altitude <= 200 && altitude>= 160){
            // Yellow Zone !!!
            red = map(altitude,160,200,255,0);
            green = 255 ;

          }
          else if(altitude <= 159 && altitude>= 120){
            // Orange Zone !!!
            green = map(altitude,120,159,0,255);
            red = 255;
          }
          else{
            // RED Zone !!!
            green = 0;
            red = 255;
          }
        }


        const date = new Date(viewer.clock.currentTime)
        //const dateformat = date.toLocaleString('en-US',{ weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' ,timezone: 'UTC',  })
        const dateformat = date.toLocaleString('en-GB',{ hour12: false ,timeZone: 'UTC',  })
        $(".display-time").text(dateformat)
        viewer.entities.values[0].path.material.color._value = Cesium.Color.fromBytes(red,green,0)
        viewer2.entities.values[0].path.material.color._value = Cesium.Color.fromBytes(red,green,0)
        viewer2.clock.currentTime = viewer.clock.currentTime

      };
      function trackedEntity() {
        if (isTracked === true) {
          viewer.trackedEntity = undefined
          viewer.selectedEntity = undefined
          isTracked = false
        }
        else if (isTracked === false){
          viewer.trackedEntity = viewer.entities.values[0]
          viewer.selectedEntity = viewer.entities.values[0]
          isTracked = true
        }
      }

      $('#show-earth2').click(function() {
        $('#cesiumContainer2').toggle(1000).css("background-color","red");
      })
      //$('#cesiumContainer2.cesium-viewer-animationContainer').css({"display" : "none"})
      document.querySelector("#cesiumContainer2 > div > div.cesium-viewer-animationContainer").style.display = 'none';
      document.querySelector("#cesiumContainer2 > div > div.cesium-viewer-bottom").style.display = 'none';
      let worldPosition;
      let distance;

      function syncView() {
        // The center of the view is the point that the 3D camera is focusing on
        const viewCenter = new Cesium.Cartesian2(
          Math.floor(viewer.canvas.clientWidth / 2),
          Math.floor(viewer.canvas.clientHeight / 2)
        );
        //console.log(viewCenter)
        // Given the pixel in the center, get the world position
        const newWorldPosition = viewer.scene.camera.pickEllipsoid(
          viewCenter
        );
        //console.log(newWorldPosition)
        if (Cesium.defined(newWorldPosition)) {
          // Guard against the case where the center of the screen
          // does not fall on a position on the globe
          worldPosition = newWorldPosition;
        }
        // Get the distance between the world position of the point the camera is focusing on, and the camera's world position
        distance = Cesium.Cartesian3.distance(
          worldPosition,
          viewer.scene.camera.positionWC
        );
        //console.log(distance)
        //console.log(distance)
        // Tell the 2D camera to look at the point of focus. The distance controls how zoomed in the 2D view is
        // (try replacing `distance` in the line below with `1e7`. The view will still sync, but will have a constant zoom)
        viewer2.scene.camera.lookAt(
          worldPosition,
          new Cesium.Cartesian3(0.0, 0.0, distance+10000000)
        );
      }
      
      // Apply our sync function every time the 3D camera view changes
      viewer.camera.changed.addEventListener(syncView);
      // By default, the `camera.changed` event will trigger when the camera has changed by 50%
      // To make it more sensitive, we can bring down this sensitivity
      viewer.camera.percentageChanged = 0.0001;
      
      // Since the 2D view follows the 3D view, we disable any
      // camera movement on the 2D view
      viewer2.scene.screenSpaceCameraController.enableRotate = false;
      viewer2.scene.screenSpaceCameraController.enableTranslate = false;
      viewer2.scene.screenSpaceCameraController.enableZoom = false;
      viewer2.scene.screenSpaceCameraController.enableTilt = false;
      viewer2.scene.screenSpaceCameraController.enableLook = false;
    </script>
  </body>
</html>
